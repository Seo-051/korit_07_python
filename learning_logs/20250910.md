# 금일 수업 계획
1. coffee_machine procedure-oriented programming
2. coffee_machine object-oriented programing version
3. class_static

```python

profit += MENU['라떼']['가격']
print(f'수익 : ${profit}')

# 하드코딩 ver
# resource['물'] -= MENU['라떼']['재료']['물']
# print(f'물: ${profit}')

# 반복문 ver
for key in resource :
    resource[key] -= MENU['라떼']['재료'][key]
    if key == '커피':
        print(f'{key} : {resource[key]}g')
    else :
        print(f'{key} : {resource[key]}ml')
```

20250908에


 if choice == '에스프레소':
            for key in resource:
                resource[key] -= MENU['에스프레소']['제료'][key]
                if resource[key] < 0:
                    print(f'{key}가 부족합니다.')
        elif choice == '라떼':
 
```python

def process_coins():
    """동전들을 입력 받아 전체 금액을 반환하는 함수 call3() 유형"""
    # 쿼터, 다임, 니켈, 페니 네 종류의 동전
    '''
    쿼터 = 0.25 달러             quarter
    다임 = 0.1 달러              dime
    니켈 = 0.05 달러             nickel
    페니 = 0.01 달러             penny
    '''
    sum = 0
    # 이 부분에 로직이 들어가야 할겁니다.
    # quarter = float(input('쿼터 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.25
    # dime = float(input('다임 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.1
    # nickel = float(input('니켈 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.05
    # penny = float(input('페니 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.01
    # sum = quarter + dime + nickel + penny
    # 근데 지금 함수 하나에 지역 변수가 5 개나 있다는 사실을 알 수 있습니다.
    # 그리고 다수의 수강생분들이 빡세게 collections 쓰는 바람에 내부에 조건문이 있거나
    # 반복문이 있는 경우도 있습니다.
    sum += float(input('쿼터 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.25
    sum += float(input('다임 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.1
    sum += float(input('니켈 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.05
    sum += float(input('페니 동전을 몇 개나 넣으시겠습니까? >>> ')) * 0.01
    return sum

 def process_coins(self):
        """투입된 동전으로부터 계산된 총액을 반환합니다."""
        print("동전을 투입해주세요.")
        for coin in self.COIN_VALUES:
            self.money_received += int(input(f"{coin}는 몇 개입니까?: ")) * self.COIN_VALUES[coin]
        return self.money_received

    def make_payment(self, cost):
        """지불이 성공했을 때 True를 반환하고, 돈이 부족하면 False를 반환합니다."""
        self.process_coins()
        if self.money_received >= cost:
            change = round(self.money_received - cost, 2)
            print(f"여기 잔돈 {self.CURRENCY}{change}를 반환합니다.")
            self.profit += cost
            self.money_received = 0
            return True
        else:
            print("죄송합니다. 돈이 충분하지 않습니다. 돈을 반환합니다.")
            self.money_received = 0
            return False
```
이상의 코드는 pop version의 process_coins()/is_transaction_successful() 과
oop version의 process_coins()/make_payment()입니다.

주목해야 할 점은 make_payment() 내부에서 process_coins()를 호출한다는 점입니다.
그 의미는 pop version의 main에서는 process_coins()를 호출하여 money_received에 저장할
필요가 있었지만 oop version에서는 make_payment()만 호출하면 알아서 process_coins()의 결과괎을 가지고 온다는 점입니다.

그 결과로 is_transaction